<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="author" content="shearer12345"><title>Simulation and Time</title><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui" name="viewport"><link href="reveal.js/css/reveal.css" rel="stylesheet"><link rel="stylesheet" href="reveal.js/css/theme/black.css" id="theme"><script type="text/x-mathjax-config">MathJax.Hub.Config({
tex2jax: {
  inlineMath: [["\\(", "\\)"]],
  displayMath: [["\\[", "\\]"]],
  ignoreClass: "nostem|nolatexmath"
},
asciimath2jax: {
  delimiters: [["\\$", "\\$"]],
  ignoreClass: "nostem|noasciimath"
},
TeX: { equationNumbers: { autoNumber: "none" } }
});</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.4.0/MathJax.js?config=TeX-MML-AM_HTMLorMML"></script><link href="reveal.js/lib/css/zenburn.css" rel="stylesheet"><script>document.write( '<link rel="stylesheet" href="reveal.js/css/print/' + ( window.location.search.match( /print-pdf/gi ) ? 'pdf' : 'paper' ) + '.css" type="text/css" media="print">' );</script></head><body><div class="reveal"><div class="slides"><section><h1>Simulation and Time</h1><p><small>shearer12345</small></p></section><section><section id="_simulation"><h2>Simulation</h2><div class="ulist"><ul><li><p>Changing a model over time</p></li><li><p>In general all game physics is fakery</p><div class="ulist"><ul><li><p>i.e. a "model" of how things change - not 100% correct</p></li></ul></div></li><li><p>We have choices about how much we fake things</p></li><li><p>And choices about efficient algorithms etc</p></li></ul></div></section><section id="_step_by_step"><h2>Step-by-step</h2><div class="ulist"><ul><li><p>In games almost always step-by-step</p><div class="ulist"><ul><li><p>a few cases we can compute results directly, with timesteps (see later)</p></li></ul></div></li></ul></div></section><section id="_constraints"><h2>Constraints</h2><div class="ulist"><ul><li><p>Simulating in real-time means making larger approximations</p><div class="ulist"><ul><li><p>CPU/GPU constraints</p></li><li><p>We may be happy with larger errors for lower computational cost</p></li></ul></div></li><li><p>Simulation inevitably requires some mathematics</p><div class="ulist"><ul><li><p>\(=&gt;\) programmer mathematics ability may influence the choice/implementation of techniques</p></li></ul></div></li></ul></div></section></section>
<section><section id="_technical_terms"><h2>Technical terms</h2><div class="ulist"><ul><li><p>Time</p></li><li><p>Length</p></li><li><p>Position</p></li><li><p>Velocity</p></li><li><p>Speed</p></li><li><p>Acceleration</p></li><li><p>Mass</p></li><li><p>Force</p></li></ul></div></section><section id="_time"><h2>Time</h2><div class="ulist"><ul><li><p>A measure of duration</p></li><li><p>A scalar (single dimensional / not a vector / has no direction)</p></li><li><p>Units are seconds: (\(s\))</p></li><li><p>Usual symbol is \(t\)</p></li><li><p>e.g. \(t = 4.3s\)</p></li></ul></div></section><section id="_length"><h2>Length</h2><div class="ulist"><ul><li><p>A measure of space</p></li><li><p>Units are metres: (\(m\))</p></li><li><p>e.g. \(l = 3.6m\)</p></li></ul></div></section><section id="_position"><h2>Position</h2><div class="ulist"><ul><li><p>Where in space a point is, relative to some base point</p></li><li><p>Units are metres: (\(m\))</p></li><li><p>A vector (\(m\) on each axis)</p></li><li><p>Usual symbol is \(\vec{p}\) or \(\vec{r}\)</p></li><li><p>e.g. \(\vec{p} = (2.3, 4.5)\)</p></li></ul></div></section><section id="_velocity"><h2>Velocity</h2><div class="ulist"><ul><li><p>The rate of change of position over time (derivative)</p></li><li><p>Units are metres per second: \(\frac m s\) (also \(m s^{-1}\))</p></li><li><p>A vector (\(m s^{-1}\) on each axis)</p></li><li><p>Usual symbol is \(\vec{v}\)</p></li><li><p>e.g. \(\vec{v} = (0.4, 2.3){m s^{-1}}\)</p></li></ul></div></section><section id="_speed"><h2>Speed</h2><div class="ulist"><ul><li><p>Magnitude of velocity: \(|v|\)</p><div class="ulist"><ul><li><p>i.e. independent of the direction</p></li></ul></div></li><li><p>Units are also metres per second: \(\frac m s\) (also \(m s^{-1}\))</p></li><li><p>A scalar (has no direction)</p></li><li><p>e.g. \(speed = 2.33{m s^{-1}}\)</p></li><li><p>Can compute from velocity - (and reverse if have the direction)</p></li></ul></div></section><section id="_computing_speed"><h2>Computing Speed</h2><div class="ulist"><ul><li><p>Magnitude of a vector is its length</p></li><li><p>How do we compute the length of vector?</p><div class="ulist"><ul><li class="fragment"><p>Square root of the sum of the squares</p></li></ul></div></li></ul></div></section><section id="_computing_speed_2d"><h2>Computing Speed 2D</h2><div class="ulist"><ul><li><p>if \(\vec{v} = (x, y)\)</p><div class="ulist"><ul><li><p>\(|v| = \sqrt{x^2 + y^2}\)</p></li></ul></div></li><li><p>if \(\vec{v} = (0.4, 2.3)\)</p><div class="ulist"><ul><li><p>\(|v| = \sqrt{0.4^2 + 2.3^2} = 2.33\)</p></li></ul></div></li></ul></div></section><section id="_computing_speed_3d"><h2>Computing Speed 3D</h2><div class="ulist"><ul><li><p>if \(\vec{v} = (x, y, z)\)</p><div class="ulist"><ul><li><p>\(|v| = \sqrt{x^2 + y^2 + z^2}\)</p></li></ul></div></li><li><p>if \(\vec{v} = (0.4, 2.3, 3.2)\)</p><div class="ulist"><ul><li><p>\(|v| = \sqrt{0.4^2 + 2.3^2 + 3.2^2} = 3.96\)</p></li></ul></div></li></ul></div></section><section id="_acceleration"><h2>Acceleration</h2><div class="ulist"><ul><li><p>The rate of change of velocity over time (derivative)</p></li><li><p>Units are metres per second per second: \(\frac m {s^2}\) (also \(m s^{-2}\))</p></li><li><p>A vector (\(m s^{-2}\) on each axis)</p></li><li><p>Usual symbol is \(\vec{a}\)</p></li><li><p>e.g. \(\vec{a} = (0.4, 2.3){m s^{-2}}\)</p></li></ul></div></section><section id="_mass"><h2>Mass</h2><div class="ulist"><ul><li><p>A measure of resistance to change of For every action there is an equal and opposite reaction.</p></li></ul></div>
<div class="paragraph"><p>If two objects bump into each other they will react by moving apart.motion when a force is applied
* Is NOT the weight of an object (that depends on gravitational pull)
* Units are \(kg\)
* A scalar (has no direction)
* Usual symbol is \(m\)
* e.g. \(m = 45.3kg\)</p></div></section><section id="_force"><h2>Force</h2><div class="ulist"><ul><li><p>Causes objects to change velocity (when unopposed)</p></li><li><p>Units are Newtons: (\(N\))</p></li><li><p>A vector - has direction as well as magnitude</p></li><li><p>Usual symbol is \(F\)</p></li><li><p>e.g. \(F = 153.3N\)</p></li></ul></div></section></section>
<section><section id="_vectors"><h2>Vectors</h2><div class="ulist"><ul><li><p>Vectors are a good representation</p></li><li><p>Easy to understand</p></li><li><p>Moving from 2D to 3D is easier</p></li><li><p>Efficient for processing</p></li></ul></div></section><section id="_magnitude_and_direction"><h2>Magnitude and direction</h2><div class="ulist"><ul><li><p>You can always computed magnitude and direction from a vector</p></li><li><p>Using magnitude and direction is hard work</p></li><li><p>Using magnitude and direction frequently means using \(sin\) and \(cos\)</p><div class="ulist"><ul><li><p>which are relatively expensive operations</p></li></ul></div></li></ul></div></section></section>
<section id="_units"><h2>Units</h2><div class="ulist"><ul><li><p>Use <strong>SI</strong> Units</p><div class="ulist"><ul><li><p>International System of Units (Système international d&#8217;unités, SI)</p></li></ul></div></li><li><p>Will make your life <strong>MUCH</strong> easier</p><div class="ulist"><ul><li><p>avoid inches, miles</p></li></ul></div></li></ul></div></section>
<section><section id="_newton_s_laws_of_motion"><h2>Newton’s Laws of Motion</h2><div class="ulist"><ul><li><p>What are they?</p></li></ul></div></section><section id="_newton_s_first_law_of_motion"><h2>Newton’s First Law of Motion</h2><div class="ulist"><ul><li><p>Every object in a state of uniform For every action there is an equal and opposite reaction.</p></li></ul></div>
<div class="paragraph"><p>If two objects bump into each other they will react by moving apart.</p></div></section><section id="_newton_s_second_law_of_motion"><h2>Newton’s Second Law of Motion</h2><div class="ulist"><ul><li><p>A force is applied only to the concept we commonly call acceleration</p></li><li><p>An object&#8217;s mass, acceleration, and the applied force may be represented by</p><div class="ulist"><ul><li><p>\(\LARGE F = ma\)</p></li></ul></div></li></ul></div></section><section id="_newton_s_third_law_of_motion"><h2>Newton’s Third Law of Motion</h2><div class="ulist"><ul><li><p>For every action there is an equal and opposite reaction.</p></li><li><p>If two objects bump into each other they will react by moving apart</p></li></ul></div></section></section>
<section id="_using_acceleration_in_your_game"><h2>Using acceleration in your game</h2><div class="ulist"><ul><li><p>Some representation of velocity in your game is vital for objects to move (new positions calculated from old positions, velocity and time)</p></li><li><p>You don&#8217;t have to use acceleration</p><div class="ulist"><ul><li><p>your game could set velocity values directly</p></li><li><p>this is unrealistic (compared to real world), but frequently doesn&#8217;t matter</p><div class="ulist"><ul><li><p>e.g. changing from not moving to travelling at \(5{m s^{-1}}\) instantly is an infinite acceleration</p></li></ul></div></li></ul></div></li></ul></div></section>
<section><section id="_simulation_steps_finally"><h2>Simulation steps (finally)</h2><div class="ulist"><ul><li><p>If we know the position and velocity of an object we can calculate its position some time later</p><div class="ulist"><ul><li><p>\(\vec{p'} = \vec{p} + \vec{v} * \Delta t\)</p></li><li><p>this is called integration</p></li></ul></div></li><li><p>This works just fine as long a \(\vec{v}\) is constant throughout \(\Delta t\)</p></li></ul></div></section><section id="_simulation_steps_simple_code"><h2>Simulation steps (simple code)</h2><div class="listingblock"><div class="content"><pre class="highlight"><code class="cpp language-cpp">position = position + velocity * dt;</code></pre></div></div></section><section id="_smaller_simulation_steps"><h2>Smaller simulation steps</h2><div class="ulist"><ul><li><p>Assuming velocity is constant through a simulation step is frequently wrong</p></li><li><p>The impact of the incorrect assumption can be mitigated by:</p><div class="olist arabic"><ol class="arabic"><li><p>reducing the duration of the time step</p></li><li><p>using a more sophisticated form of integration (e.g. Runge-Kutta 4)</p></li></ol></div></li></ul></div>
<div class="paragraph"><p>See also: <a href="http://gafferongames.com/game-physics/integration-basics/" class="bare">http://gafferongames.com/game-physics/integration-basics/</a></p></div></section><section id="_changing_velocity_over_time"><h2>Changing velocity over time</h2><div class="ulist"><ul><li><p>Just as we can change position according to velocity we can change velocity according to acceleration</p><div class="ulist"><ul><li><p>\(\vec{v'} = \vec{v} + \vec{a} * \Delta t\)</p></li></ul></div></li><li><p>Assumes that \(\vec{a}\) is constant throughout \(\Delta t\)</p></li></ul></div></section><section id="_changing_velocity_changing_position"><h2>Changing velocity, Changing position</h2><div class="ulist"><ul><li><p>Usual practice is to use acceleration to calculate new velocities</p></li><li><p>THEN use those new velocities to calculate new positions</p></li></ul></div></section></section>
<section><section id="_time_and_time_steps"><h2>Time and time-steps</h2><div class="ulist"><ul><li><p>It&#8217;s important to be able to obtain the real time in games</p><div class="ulist"><ul><li><p>so that we can make sure we simulate and render appropriately</p></li></ul></div></li></ul></div></section><section id="_seconds_vs_milliseconds"><h2>Seconds vs. Milliseconds</h2><div class="ulist"><ul><li><p><strong>many</strong> <strong>many</strong> engines/libraries use milliseconds as their base unit of time</p><div class="ulist"><ul><li><p>including SDL2 - grrr - <span class="image"><img src="./assets//emoticons/Smiley_green_alien_GRRR.svg" alt="Smiley_green_alien_GRRR" height="100"></span></p></li></ul></div></li><li><p>Why?</p><div class="ulist"><ul><li class="fragment"><p>for many purposes milliseconds is enough precision</p></li><li class="fragment"><p>for many purposes time in \(ms\) can be represented by an integer</p></li></ul></div></li></ul></div></section><section id="_use_seconds"><h2>Use Seconds</h2><div class="ulist"><ul><li><p>Using \(seconds\) everywhere is my <strong>strong</strong> recommendation</p></li><li><p>possibly worth wrapping functions/methods that use \(ms\) to use \(seconds\)</p></li></ul></div></section><section id="_sdl_getticks"><h2>SDL_GetTicks</h2><div class="ulist"><ul><li><p>SDL_GetTicks() gives you the number of milliseconds since the SDL library initialization (as 32 bit int)</p></li><li><p>How many milliseconds per frame</p><div class="ulist"><ul><li><p>at 60fps?</p></li><li><p>at 100fps?</p></li><li><p>at 120fps?</p></li></ul></div></li></ul></div></section><section id="_c_11_chrono"><h2>C++11 - chrono</h2><div class="listingblock"><div class="content"><pre class="highlight"><code class="cpp language-cpp">#include &lt;iostream&gt;
#include &lt;chrono&gt;
typedef std::chrono::high_resolution_clock Clock;

int main()
{
    auto t1 = Clock::now();
    auto t2 = Clock::now();
    std::cout &lt;&lt; "Delta t2-t1: "
              &lt;&lt; std::chrono::duration_cast&lt;std::chrono::nanoseconds&gt;(t2 - t1).count()
              &lt;&lt; " nanoseconds" &lt;&lt; std::endl;
}</code></pre></div></div>
<div class="paragraph"><p><a href="http://stackoverflow.com/questions/26440860/sdl-getticks-accuracy-below-the-millisecond-level" class="bare">http://stackoverflow.com/questions/26440860/sdl-getticks-accuracy-below-the-millisecond-level</a></p></div></section><section id="_simulate_at_render_rate"><h2>Simulate at render-rate?</h2><div class="ulist"><ul><li><p>Your speed of render will be variable</p><div class="ulist"><ul><li><p>across machines</p></li><li><p>over time</p></li></ul></div></li><li><p>Track how long it has been since the last render and simulate that length of time</p><div class="ulist"><ul><li><p>what happens if no-vsync</p></li><li><p>??</p></li></ul></div></li></ul></div></section><section id="_fix_your_time_step"><h2>Fix your time step???</h2><div class="ulist"><ul><li><p>Adjusting your simulation rate to vary with render rate is non-deterministic</p><div class="ulist"><ul><li><p>for networking and test determinism in important (more next year)</p></li><li><p>you could simulate with a fixed time step</p></li><li><p><a href="http://gafferongames.com/game-physics/fix-your-timestep/" class="bare">http://gafferongames.com/game-physics/fix-your-timestep/</a></p></li></ul></div></li></ul></div></section></section>
<section><section id="_simulation_correctness_the_rare_case"><h2>Simulation correctness (the rare case)</h2><div class="ulist"><ul><li><p>Only in <strong>some</strong> situations the future may be calculated analytically</p><div class="ulist"><ul><li><p>for very simple models (or parts of a more complex model)</p></li><li><p>e.g. determine analytically when a ball will hit the floor</p></li></ul></div></li></ul></div></section><section id="_equations_for_a_falling_body"><h2>Equations for a falling body</h2><div class="ulist"><ul><li><p>Assuming constant acceleration</p></li><li><p>Assuming no air resistance</p></li></ul></div></section><section id="_equations_for_a_falling_body_2"><h2>Equations for a falling body 2</h2><div class="ulist"><ul><li><p>Distance \(d\) travelled by an object falling for time \(t\):</p></li></ul></div>
<div class="paragraph"><p>\(d=\frac{1}{2}(g*t^2)\)</p></div>
<div class="ulist"><ul><li><p>Time \(t\) taken for an object to fall distance \(d\):</p></li></ul></div>
<div class="paragraph"><p>\(t =\ \sqrt {\frac{2d}{g}} \)</p></div>
<div class="paragraph"><p><a href="https://en.wikipedia.org/wiki/Equations_for_a_falling_body" class="bare">https://en.wikipedia.org/wiki/Equations_for_a_falling_body</a></p></div></section><section id="_distance_d_travelled_by_an_object_falling_for_time_t"><h2>Distance (d) travelled by an object falling for time (t)</h2><div class="ulist"><ul><li><p>let&#8217;s assume t is 2 seconds</p></li><li><p>what is g?</p></li></ul></div>
<div class="paragraph"><p>\(d=\frac{1}{2}(g*t^2)\)</p></div>
<div class="ulist"><ul><li><p>&#8658; d = ???</p></li></ul></div></section><section id="_distance_d_travelled_by_an_object_falling_for_time_t_2"><h2>Distance (d) travelled by an object falling for time (t) 2</h2><div class="ulist"><ul><li><p>let&#8217;s assume t is 2 seconds</p></li><li><p>what is g?</p><div class="ulist"><ul><li><p>force/acceleration due to gravity</p></li><li><p>= 9.81 meters per second per second</p></li></ul></div></li></ul></div></section><section id="_distance_d_travelled_by_an_object_falling_for_time_t_3"><h2>Distance (d) travelled by an object falling for time (t) 3</h2><div class="ulist"><ul><li><p>t = 2.00</p></li><li><p>g = 9.81</p></li></ul></div>
<div class="paragraph"><p>\(d=\frac{1}{2}(g*t^2)\)</p></div>
<div class="ulist"><ul><li><p>&#8658; d = 19.62 meters !!</p></li></ul></div></section><section id="_time_t_taken_for_an_object_to_fall_distance_d"><h2>Time (t) taken for an object to fall distance (d)</h2><div class="ulist"><ul><li><p>g = 9.81</p></li><li><p>d = 54 meters (height of the Leaning Tower of Pisa)</p></li></ul></div>
<div class="paragraph"><p>\(t =\ \sqrt {\frac{2d}{g}} \)</p></div>
<div class="ulist"><ul><li><p>&#8658; t = ???</p></li></ul></div></section><section id="_time_t_taken_for_an_object_to_fall_distance_d_2"><h2>Time (t) taken for an object to fall distance (d) 2</h2><div class="ulist"><ul><li><p>g = 9.81</p></li><li><p>d = 54 meters (height of the Leaning Tower of Pisa)</p></li></ul></div>
<div class="paragraph"><p>\(t =\ \sqrt {\frac{2d}{g}} \)</p></div>
<div class="ulist"><ul><li><p>&#8658; t = sqrt(2 × 54) / (9.81) = 11.01)</p></li><li><p>&#8658; t = 3.32</p></li></ul></div></section></section>
<section id="_simulation_incorrectness_the_normal_case"><h2>Simulation incorrectness (the normal case)</h2><div class="ulist"><ul><li><p>the vast majority of game simulations cannot be solved analytically</p><div class="ulist"><ul><li><p>see three-body problem (" no general analytical solution for the three-body problem") - <a href="https://en.wikipedia.org/wiki/Three-body_problem" class="bare">https://en.wikipedia.org/wiki/Three-body_problem</a></p></li></ul></div></li><li><p>so we solve instead by taking time steps</p><div class="ulist"><ul><li><p>and assuming (usually incorrectly) that some properties don&#8217;t change during that step</p></li><li><p>this means that our simulations are <strong>INCORRECT</strong></p></li></ul></div></li></ul></div></section>
<section id="_problems_due_to_simulation_incorrectness"><h2>Problems due to simulation incorrectness</h2><div class="ulist"><ul><li><p>incorrect gain (or loss) of energy in the system</p><div class="ulist"><ul><li><p>leading to instability / blowing up</p></li></ul></div></li></ul></div></section>
<section id="_workshop_activities_1"><h2>Workshop activities 1</h2><div class="ulist"><ul><li><p>use SDL_GetTicks to measure how long each frame takes to render</p><div class="ulist"><ul><li><p>print to console</p></li></ul></div></li><li><p>disable vsync (in driver) and repeat</p><div class="ulist"><ul><li><p>what happens to the time?</p></li><li><p>what happens to CPU usage?</p></li><li><p>what&#8217;s going on</p></li></ul></div></li></ul></div></section>
<section id="_workshop_activities_2"><h2>Workshop activities 2</h2><div class="ulist"><ul><li><p>use std::chrono::high_resolution_clock to measure frame times</p></li><li><p>modify your game so that it simulates the correct amount of time per frame</p></li></ul></div></section>
<section id="_workshop_activities_2_2"><h2>Workshop activities 2</h2><div class="ulist"><ul><li><p>make a sprite that orbits (like the Earth) around the centre of the screen (the Sun)</p><div class="ulist"><ul><li><p>you could also render the Sun if you like</p></li></ul></div></li><li><p>it should have a starting velocity perpendicular to the direction of the sun</p><div class="ulist"><ul><li><p>at right-angles to the sun</p></li><li><p>easy if you start it right above, or right below the sun</p></li></ul></div></li><li><p>it should have an acceleration towards the Sun proportional to the distance</p><div class="ulist"><ul><li><p>correctly inversely proportional to the square of the distance</p></li><li><p>the mass of the "sprite" doesn&#8217;t matter in this case - why not?</p></li></ul></div></li></ul></div></section>
<section id="_workshop_activities_2_3"><h2>Workshop activities 2</h2><div class="ulist"><ul><li><p>adjust the starting velocity so the Earth doesn&#8217;t immediately:</p><div class="ulist"><ul><li><p>crash into the Sun</p></li><li><p>fly off into space</p></li></ul></div></li><li><p>tweak that value to maintain the orbit for longer</p></li><li><p>what happens if you do two simulation steps each frame, each of half the length of time?</p><div class="ulist"><ul><li><p>or 4 steps, each a 1/4 of the time?</p></li></ul></div></li></ul></div></section></div></div><script src="reveal.js/lib/js/head.min.js"></script><script src="reveal.js/js/reveal.js"></script><script>// See https://github.com/hakimel/reveal.js#configuration for a full list of configuration options
Reveal.initialize({
  // Display controls in the bottom right corner
  controls: true,
  // Display a presentation progress bar
  progress: true,
  // Display the page number of the current slide
  slideNumber: false,
  // Push each slide change to the browser history
  history: false,
  // Enable keyboard shortcuts for navigation
  keyboard: true,
  // Enable the slide overview mode
  overview: true,
  // Vertical centering of slides
  center: true,
  // Enables touch navigation on devices with touch input
  touch: true,
  // Loop the presentation
  loop: false,
  // Change the presentation direction to be RTL
  rtl: false,
  // Turns fragments on and off globally
  fragments: true,
  // Flags if the presentation is running in an embedded mode,
  // i.e. contained within a limited portion of the screen
  embedded: false,
  // Number of milliseconds between automatically proceeding to the
  // next slide, disabled when set to 0, this value can be overwritten
  // by using a data-autoslide attribute on your slides
  autoSlide: 0,
  // Stop auto-sliding after user input
  autoSlideStoppable: true,
  // Enable slide navigation via mouse wheel
  mouseWheel: false,
  // Hides the address bar on mobile devices
  hideAddressBar: true,
  // Opens links in an iframe preview overlay
  previewLinks: false,
  // Theme (e.g., beige, black, league, night, serif, simple, sky, solarized, white)
  // NOTE setting the theme in the config no longer works in reveal.js 3.x
  //theme: Reveal.getQueryHash().theme || 'black',
  // Transition style (e.g., none, fade, slide, convex, concave, zoom)
  transition: Reveal.getQueryHash().transition || 'slide',
  // Transition speed (e.g., default, fast, slow)
  transitionSpeed: 'default',
  // Transition style for full page slide backgrounds (e.g., none, fade, slide, convex, concave, zoom)
  backgroundTransition: 'fade',
  // Number of slides away from the current that are visible
  viewDistance: 3,
  // Parallax background image (e.g., "'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg'")
  parallaxBackgroundImage: '',
  // Parallax background size in CSS syntax (e.g., "2100px 900px")
  parallaxBackgroundSize: '',

  // The "normal" size of the presentation, aspect ratio will be preserved
  // when the presentation is scaled to fit different resolutions. Can be
  // specified using percentage units.
  width: 960,
  height: 700,

  // Factor of the display size that should remain empty around the content
  margin: 0.1,

  // Bounds for smallest/largest possible scale to apply to content
  minScale: 0.2,
  maxScale: 1.5,

  // Optional libraries used to extend on reveal.js
  dependencies: [
      { src: 'reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
      { src: 'reveal.js/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
      { src: 'reveal.js/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
      { src: 'reveal.js/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
      { src: 'reveal.js/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
      { src: 'reveal.js/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
  ]
});</script></body></html>