<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><title>Game Loop and Timing</title><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui" name="viewport"><link href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.3.0/css/reveal.css" rel="stylesheet"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.3.0/css/theme/black.css" id="theme"><link href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.3.0/lib/css/zenburn.css" rel="stylesheet"><script>document.write( '<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.3.0/css/print/' + ( window.location.search.match( /print-pdf/gi ) ? 'pdf' : 'paper' ) + '.css" type="text/css" media="print">' );</script></head><body><div class="reveal"><div class="slides"><section class="title"><h1>Game Loop and Timing</h1></section><section id="_overview"><h2>Overview</h2><div class="ulist"><ul><li><p>Game Loop</p></li><li><p>Timing</p></li><li><p>Game Loop Timing Solutions</p></li><li><p>Determinism</p></li></ul></div></section>
<section id="_what_strong_any_strong_game_needs_to_do"><h2>What <strong>ANY</strong> Game needs to do</h2><div class="ulist"><ul><li><p>Show to a player images and sound that change, in response to player input, sufficiently quickly to provide for an "interactive" experience</p><div class="ulist"><ul><li><p>Render (display), also with sound</p></li><li><p>Get input from player, or players</p></li><li><p>Update a model of the world</p></li><li><p><strong>REPEAT</strong></p></li></ul></div></li></ul></div>
<div class="admonitionblock note"><table><tr><td class="icon"><div class="title">Note</div></td><td class="content">order can be altered</td></tr></table></div></section>
<section id="_game_loop_bad"><h2>Game Loop (BAD!)</h2><div class="listingblock"><div class="title">gameLoop/main.cpp</div><div class="content"><pre class="highlight"><code class="cpp language-cpp">int main(int argc, char* argv[])
{
	bool running = false;
	if (init() == 0) running = true;

	while(running) {
		SDL_LogInfo(SDL_LOG_CATEGORY_APPLICATION,
			"Game Loop start: %i\n", SDL_GetTicks());
		process_input();
		update();
		render();

		//wait for some amount of time
	}
	return 0;
}</code></pre></div></div></section>
<section id="_what_s_wrong_with_that"><h2>What&#8217;s wrong with that??</h2><div class="ulist"><ul><li><p>Let&#8217;s run that program and see what happens</p><div class="ulist"><ul><li><p>What do you think will happen?</p></li></ul></div></li></ul></div></section>
<section><section id="_demo"><h2>DEMO</h2><div class="ulist"><ul><li><p>DEMO :-)</p></li></ul></div></section><section id="_demo_issues"><h2>Demo Issues</h2><div class="olist arabic"><ol class="arabic"><li><p>Hard-running</p><div class="ulist"><ul><li><p>runs as fast as it can</p></li><li><p>how fast? We don&#8217;t even know!</p></li><li><p>runs at different speeds on different hardware</p></li><li><p>runs at different speeds when doing different things per step/frame</p></li><li><p>our render rate/frequency is fixed/couple to out step rate/frequency</p></li></ul></div></li></ol></div></section><section id="_demo_issues_2"><h2>Demo Issues 2</h2><div class="olist arabic"><ol class="arabic"><li><p>Doesn&#8217;t/can&#8217;t exit</p></li><li><p>Doesn&#8217;t actual <strong>do</strong> anything</p><div class="ulist"><ul><li><p>render, get input, update</p></li></ul></div></li></ol></div></section></section>
<section id="_milliseconds_per_strong_frame_strong_and_per_strong_step_strong"><h2>Milliseconds per <strong>Frame</strong> and per <strong>Step</strong></h2><div class="ulist"><ul><li><p>What we&#8217;re actually interested in?</p><div class="ulist"><ul><li><p>How long did each take?</p></li><li><p>Or the time since the last time we were in this place?</p></li></ul></div></li><li><p>We can calculate FPS from these</p></li></ul></div></section>
<section id="__strong_frames_strong_and_strong_steps_strong_per_second"><h2><strong>Frames</strong> and <strong>Steps</strong> Per Second</h2><div class="ulist"><ul><li><p>FPS is the frequently quoted metric</p><div class="ulist"><ul><li><p>FPS - Frames Per Second - how many times <code>render</code> is called per second</p></li><li><p>Steps Per Second - how many times <code>update</code> is called per second</p></li></ul></div></li></ul></div></section>
<section id="_time_in_your_game_loop"><h2>Time in your Game Loop</h2><div class="ulist"><ul><li><p>There are <strong>many, many</strong> ways better game loops</p></li><li><p>The key thing is to <strong>measure</strong> real-time and use that information</p></li></ul></div></section>
<section id="_real_time_system"><h2>Real-time System</h2><div class="ulist"><ul><li><p>The issue we&#8217;re looking at is more generical called "Real-time Systems"</p></li></ul></div>
<div class="quoteblock"><blockquote>A system is said to be real-time if the total correctness of an operation depends not only upon its logical correctness, but also upon the time in which it is performed.</blockquote><div class="attribution"><cite>Principles of Concurrent and Distributed Programming</cite><br>&#8212; Mordechai Ben-Ari</div></div></section>
<section id="_relationship_with_real_world_real_time_control"><h2>Relationship with Real-World Real-time control</h2><div class="ulist"><ul><li><p>Many/most Real-World Real-time control systems have similar loops to a Game Loop</p><div class="ulist"><ul><li><p>some may have schedulers in more complex situations</p></li><li><p>some may be written to be provable to meet deadlines</p></li><li><p>Games rarely use either of these formalisms</p></li></ul></div></li></ul></div></section>
<section id="_measuring_real_time"><h2>Measuring Real-time</h2><div class="ulist"><ul><li><p>SDL2 provides a simple, not very precise, way of measuring time - <a href="https://wiki.libsdl.org/SDL_GetTicks"><code>SDL_GetTicks</code></a></p></li></ul></div>
<div class="quoteblock"><blockquote>Returns an unsigned 32-bit value representing the number of milliseconds since the SDL library initialized.</blockquote><div class="attribution"><cite>https://wiki.libsdl.org/SDL_GetTicks</cite><br>&#8212; `SDL_GetTicks` Documentation</div></div></section>
<section id="_solution_1"><h2>Solution #1</h2><div class="ulist"><ul><li><p>Limit the rate through the Game Loop based on elapsed time</p><div class="olist arabic"><ol class="arabic"><li><p>initialise a variable for the time of the next update</p><div class="ulist"><ul><li><p>from the clock</p></li><li><p>and how long from one update to the next</p></li></ul></div></li><li><p>before doing the next update, measure if we&#8217;ve got to that time already</p><div class="ulist"><ul><li><p>if not, then sleep for the extra time</p></li><li><p>don&#8217;t spin-wait / busy-wait!!!</p></li></ul></div></li></ol></div></li></ul></div></section>
<section id="_let_s_try_it_demo_2"><h2>Let&#8217;s try it - DEMO 2</h2><div class="ulist"><ul><li><p>example at <a href="http://www.koonsolo.com/news/dewitters-gameloop/">FPS dependent on Constant Game Speed</a></p></li></ul></div></section>
<section id="_reviewing_solution_1_slow_machine"><h2>Reviewing Solution #1 - Slow Machine</h2><div class="ulist"><ul><li><p>Slow machine - can&#8217;t always hit the rate</p><div class="ulist"><ul><li><p>long steps make for bad simulations</p></li><li><p>long steps make for bad renderings</p></li><li><p>we <strong>may</strong> be able to mitigate one of those</p></li></ul></div></li></ul></div></section>
<section id="_reviewing_solution_1_fast_machine"><h2>Reviewing Solution #1 - Fast Machine</h2><div class="ulist"><ul><li><p>Fast machine - easily hits the rate</p><div class="ulist"><ul><li><p>could make the simulation or rendering <strong>better</strong></p></li></ul></div></li></ul></div></section>
<section id="_accuracy_and_precision_of_time"><h2>Accuracy and Precision of Time</h2><div class="dlist"><dl><dt class="hdlist1">Accuracy</dt><dd><p>How correct the time is</p></dd><dt class="hdlist1">Precision</dt><dd><p>How precisely (fine-grained) the time is measured/represented</p></dd></dl></div></section>
<section id="_getting_accurate_precise_real_time_is_hard"><h2>Getting accurate, precise Real-time is hard</h2><div class="ulist"><ul><li><p>Most PCs get their sense of time from a "Real-time Clock"</p><div class="ulist"><ul><li><p>usually based on a vibrating piece of quartz!</p></li></ul></div></li><li><p>The quartz&#8217;s size affects clock rate</p><div class="ulist"><ul><li><p>temperature</p></li></ul></div></li><li><p>Almost all clocks <strong>drift</strong> - become inaccurate</p></li><li><p>Usually, drift is managed by getting a "better" time from the network</p><div class="ulist"><ul><li><p>usually ties back to an atomic clock</p></li></ul></div></li></ul></div>
<div class="admonitionblock note"><table><tr><td class="icon"><div class="title">Note</div></td><td class="content">for single-player games, we rarely care about accurate real-tiem</td></tr></table></div></section>
<section id="_higher_frequency_that_the_rtc"><h2>Higher-frequency that the RTC</h2><div class="ulist"><ul><li><p>RTCs don&#8217;t give very high frequency updates</p></li><li><p>Usually, the processor cycle speed is used for fine-grained time measuring</p><div class="ulist"><ul><li><p>Modern CPU&#8217;s can (<strong>DO</strong>) change this frequency!!</p></li></ul></div></li></ul></div></section>
<section id="_high_resolution_clock_a_solution"><h2>High-resolution Clock - A solution?</h2><div class="ulist"><ul><li><p>Fortunately, modern C++ does most of this for us</p><div class="ulist"><ul><li><p><a href="http://www.cplusplus.com/reference/chrono/high_resolution_clock/now/">High-resolution Clock</a></p></li></ul></div></li><li><p>API is pretty heavy</p><div class="ulist"><ul><li><p>the millisecond precision of <code>SDL_GetTicks</code> may be enough for you (mostly)</p></li></ul></div></li></ul></div></section>
<section id="_solution_2"><h2>Solution #2</h2><div class="ulist"><ul><li><p>Update amount dependent on elapsed time</p><div class="olist arabic"><ol class="arabic"><li><p>initialise a variables to measure time between updates</p><div class="ulist"><ul><li><p>from the clock</p></li></ul></div></li><li><p>between calling <code>update</code>, measure elapsed time, and pass</p><div class="ulist"><ul><li><p><code>update</code> should update less when given shorter durations</p></li></ul></div></li></ol></div></li></ul></div></section>
<section id="_solution_2_slow_machine"><h2>Solution #2 - Slow Machine</h2><div class="ulist"><ul><li><p>When Rendering is "heavy" our simulation steps get large</p><div class="ulist"><ul><li><p>Rendering rate and Simulation rate are coupled</p></li></ul></div></li><li><p>Too large steps <strong>feels</strong> bad</p><div class="ulist"><ul><li><p>may <strong>explode</strong> a simulation</p></li><li><p>may <strong>miss</strong> events (e.g. bullets pass through things)</p></li><li><p>will behave differently</p></li></ul></div></li></ul></div></section>
<section id="_solution_2_fast_machine"><h2>Solution #2 - Fast Machine</h2><div class="ulist"><ul><li><p>Rounding errors - yes, really</p><div class="ulist"><ul><li><p>Especially with a low precision clock</p><div class="ulist"><ul><li><p><code>SDL_GetTicks</code>!!!</p></li></ul></div></li></ul></div></li><li><p>Burning CPU cycles</p></li></ul></div></section>
<section id="_observation"><h2>Observation</h2><div class="ulist"><ul><li><p>Many modern games are <strong>render-limited</strong></p><div class="ulist"><ul><li><p>running smaller simulations steps is <strong>very</strong> plausible</p></li><li><p><a href="https://youtu.be/fdAOPHgW7qM">Jonathan Blow ("Braid", "The Witness") suggests 200+ Hz!</a></p></li></ul></div></li></ul></div></section>
<section id="_solution_3"><h2>Solution #3</h2><div class="ulist"><ul><li><p>For <strong>render-limited</strong> systems</p></li><li><p>Run a constant simulation rate</p><div class="ulist"><ul><li><p>reduce the frame rate</p></li></ul></div></li><li><p>i.e. make the simulation <strong>feel</strong> nice, but lower FPS, on Slow machines</p></li><li><p>in other words, do multiple updates for each render, depending on available time</p></li></ul></div>
<div class="admonitionblock note"><table><tr><td class="icon"><div class="title">Note</div></td><td class="content">Films are usually only 24fps &#8230;&#8203;</td></tr></table></div></section>
<section id="_what_we_want"><h2>What we want</h2><div class="olist arabic"><ol class="arabic"><li><p>To render as fast as we can display</p><div class="ulist"><ul><li><p>for best visual smoothness</p></li></ul></div></li><li><p>To render as well as possible</p><div class="ulist"><ul><li><p>conflicts with above</p></li></ul></div></li><li><p>To update at a <strong>constant</strong>, high rate</p></li><li><p>To interpolate visuals between simulation steps</p></li></ol></div></section>
<section id="_solution_4"><h2>Solution #4</h2><div class="ulist"><ul><li><p>Tie to V-Sync</p><div class="ulist"><ul><li><p>limit our render rate to the display rate of our <strong>physical</strong> devices</p></li><li><p>occurs in hardware</p></li><li><p>see also - Adaptive V-Sync, G-Sync, &#8230;&#8203;</p></li></ul></div></li><li><p>Not really a solution &#8230;&#8203;</p></li></ul></div></section>
<section><section id="_solution_5"><h2>Solution #5</h2><div class="ulist"><ul><li><p>Don&#8217;t do all updates every update</p></li><li><p>???? WTF ???</p></li></ul></div></section><section id="_don_t_do_all_updates_every_update_2"><h2>Don&#8217;t do all updates every update 2</h2><div class="ulist"><ul><li><p>???? WTF ???</p></li><li><p>AI may not need to update every simulation step</p></li><li><p>Physics simulation does</p></li></ul></div></section></section>
<section id="_determinism"><h2>Determinism</h2><div class="ulist"><ul><li><p>Our Game behaves the same way each time</p><div class="ulist"><ul><li><p>independent of the hardware</p></li><li><p>independent of time</p></li></ul></div></li></ul></div></section>
<section id="_values_of_determinism_briefly"><h2>Values of Determinism (briefly)</h2><div class="ulist"><ul><li><p>debugging</p><div class="ulist"><ul><li><p>if it runs differently another time, how do find the bug</p></li><li><p>simulation behaves the same in debug as release</p><div class="ulist"><ul><li><p>even if you <strong>pause</strong> executation!!</p></li></ul></div></li></ul></div></li><li><p>log replay</p></li><li><p>same simulation in multiple places</p></li></ul></div></section>
<section id="_deterministic_simulation"><h2>Deterministic Simulation</h2><div class="ulist"><ul><li><p>Fixed time step <strong>vital</strong> for deterministic simulation</p></li><li><p><strong>neccesary</strong> but not <strong>sufficent</strong></p></li></ul></div></section>
<section id="_warning_no_classes_horrid_global_variables"><h2>WARNING: no classes, horrid global variables</h2><div class="admonitionblock warning"><table><tr><td class="icon"><div class="title">Warning</div></td><td class="content">no classes, horrid global variables</td></tr></table></div>
<div class="ulist"><ul><li><p>We should create a "Game" class, or similar, to encapsulate</p></li></ul></div></section>
<section id="_recommended_reading"><h2>Recommended Reading</h2><div class="ulist"><ul><li><p><a href="http://gameprogrammingpatterns.com/game-loop.html">Game Loop - Game Programming Patterns</a></p></li><li><p><a href="http://gafferongames.com/game-physics/fix-your-timestep/">Fix your timestep - Gaffer On Games</a></p></li><li><p><a href="https://www.reddit.com/r/gamedev/comments/41v2td/a_modern_c_game_loop_template_mit/">a_modern_c_game_loop_template_mit - Reddit</a></p></li><li><p><a href="https://youtu.be/fdAOPHgW7qM">Jonathan Blow, Q&amp;A: frame-rate-independence</a></p></li><li><p><a href="https://developer.mozilla.org/en-US/docs/Games/Anatomy">Anatomy of a Video Game</a></p></li></ul></div></section></div></div><script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.3.0/lib/js/head.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.3.0/js/reveal.js"></script><script>// See https://github.com/hakimel/reveal.js#configuration for a full list of configuration options
Reveal.initialize({
  // Display controls in the bottom right corner
  controls: true,
  // Display a presentation progress bar
  progress: true,
  // Display the page number of the current slide
  slideNumber: false,
  // Push each slide change to the browser history
  history: true,
  // Enable keyboard shortcuts for navigation
  keyboard: true,
  // Enable the slide overview mode
  overview: true,
  // Vertical centering of slides
  center: true,
  // Enables touch navigation on devices with touch input
  touch: true,
  // Loop the presentation
  loop: false,
  // Change the presentation direction to be RTL
  rtl: false,
  // Turns fragments on and off globally
  fragments: true,
  // Flags if the presentation is running in an embedded mode,
  // i.e. contained within a limited portion of the screen
  embedded: false,
  // Number of milliseconds between automatically proceeding to the
  // next slide, disabled when set to 0, this value can be overwritten
  // by using a data-autoslide attribute on your slides
  autoSlide: 0,
  // Stop auto-sliding after user input
  autoSlideStoppable: true,
  // Enable slide navigation via mouse wheel
  mouseWheel: false,
  // Hides the address bar on mobile devices
  hideAddressBar: true,
  // Opens links in an iframe preview overlay
  previewLinks: false,
  // Theme (e.g., beige, black, league, night, serif, simple, sky, solarized, white)
  // NOTE setting the theme in the config no longer works in reveal.js 3.x
  //theme: Reveal.getQueryHash().theme || 'black',
  // Transition style (e.g., none, fade, slide, convex, concave, zoom)
  transition: Reveal.getQueryHash().transition || 'slide',
  // Transition speed (e.g., default, fast, slow)
  transitionSpeed: 'default',
  // Transition style for full page slide backgrounds (e.g., none, fade, slide, convex, concave, zoom)
  backgroundTransition: 'fade',
  // Number of slides away from the current that are visible
  viewDistance: 3,
  // Parallax background image (e.g., "'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg'")
  parallaxBackgroundImage: '',
  // Parallax background size in CSS syntax (e.g., "2100px 900px")
  parallaxBackgroundSize: '',

  // The "normal" size of the presentation, aspect ratio will be preserved
  // when the presentation is scaled to fit different resolutions. Can be
  // specified using percentage units.
  width: 960,
  height: 700,

  // Factor of the display size that should remain empty around the content
  margin: 0.1,

  // Bounds for smallest/largest possible scale to apply to content
  minScale: 0.2,
  maxScale: 1.5,

  // Optional libraries used to extend on reveal.js
  dependencies: [
      { src: 'https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.3.0/lib/js/classList.js', condition: function() { return !document.body.classList; } },
      { src: 'https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.3.0/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
      { src: 'https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.3.0/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
      { src: 'https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.3.0/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
      { src: 'https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.3.0/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
      { src: 'https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.3.0/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
  ]
});</script></body></html>