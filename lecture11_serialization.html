<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="author" content="shearer12345"><title>Serialization</title><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui" name="viewport"><link href="reveal.js/css/reveal.css" rel="stylesheet"><link rel="stylesheet" href="reveal.js/css/theme/black.css" id="theme"><script type="text/x-mathjax-config">MathJax.Hub.Config({
tex2jax: {
  inlineMath: [["\\(", "\\)"]],
  displayMath: [["\\[", "\\]"]],
  ignoreClass: "nostem|nolatexmath"
},
asciimath2jax: {
  delimiters: [["\\$", "\\$"]],
  ignoreClass: "nostem|noasciimath"
},
TeX: { equationNumbers: { autoNumber: "none" } }
});</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.4.0/MathJax.js?config=TeX-MML-AM_HTMLorMML"></script><link href="reveal.js/lib/css/zenburn.css" rel="stylesheet"><script>document.write( '<link rel="stylesheet" href="reveal.js/css/print/' + ( window.location.search.match( /print-pdf/gi ) ? 'pdf' : 'paper' ) + '.css" type="text/css" media="print">' );</script></head><body><div class="reveal"><div class="slides"><section><h1>Serialization</h1><p><small>shearer12345</small></p></section><section id="_summary"><h2>Summary</h2><div class="ulist"><ul><li><p>Serialization briefly</p></li><li><p>Challenges in Serialization</p></li><li><p>Libraries</p></li><li><p>Practical considerations</p></li></ul></div></section>
<section id="_serialization_briefly"><h2>Serialization briefly</h2><div class="ulist"><ul><li><p>Converting an <strong>in-memory</strong> representation to/from a form that we can write to a file or send over a network</p><div class="ulist"><ul><li><p>that form is a sequence of bit or bytes</p></li></ul></div></li><li><p>Usually, we want to be able to (re)construct an object from its serial form</p></li><li><p>File formats are one form of serialization</p></li></ul></div></section>
<section id="_serialization_and_other_names"><h2>Serialization and other names</h2><div class="ulist"><ul><li><p>AKA:</p><div class="ulist"><ul><li><p>Marshalling (<a href="https://en.wikipedia.org/wiki/Marshalling_%28computer_science%29#Comparison_with_serialization">subtly different</a>)</p></li><li><p>Pickling (Python)</p></li><li><p>Flattening</p></li></ul></div></li></ul></div></section>
<section><section id="_standard_formats_vs_standard_generic_formats"><h2>Standard formats vs Standard Generic formats</h2><div class="ulist"><ul><li><p>For this talk it&#8217;s important to make a distinction between the above</p></li><li><p>Standard formats - those for specific contexts</p><div class="ulist"><ul><li><p>e.g. image formats, such as <code>jpg</code></p></li></ul></div></li><li><p>Standard Generic formats: Those for generic context, but which still have an standard format</p><div class="ulist"><ul><li><p>e.g. XML, JSON</p></li></ul></div></li></ul></div><div class="paragraph"><p>Note: this terminology is made-up. Suggest something better</p></div></section><section id="_standard_formats_vs_standard_generic_formats_2"><h2>Standard formats vs Standard Generic formats 2</h2><div class="ulist"><ul><li><p>We&#8217;ll discuss both here, but practically we&#8217;re mostly interested in the Standard Generic formats</p><div class="ulist"><ul><li><p>We&#8217;ll delegate Standard formats to libraries</p></li></ul></div></li></ul></div></section></section>
<section><section id="_common_kinds_of_data_for_serialize_deserialize_in_games"><h2>Common kinds of data for serialize/deserialize (in games)</h2><div class="paragraph"><p>(incomplete list)</p></div><div class="ulist"><ul><li><p>Images / Textures</p></li><li><p>Audio</p></li><li><p>Video</p></li></ul></div></section><section id="_common_kinds_of_data_for_serialize_deserialize_in_games_2"><h2>Common kinds of data for serialize/deserialize (in games) 2</h2><div class="ulist"><ul><li><p>Node hierarchy</p></li><li><p>Geometry</p></li><li><p>Animation data (key-frames)</p></li><li><p>Shaders</p></li><li><p>Cameras</p></li></ul></div></section><section id="_common_kinds_of_data_for_serialize_deserialize_in_games_3"><h2>Common kinds of data for serialize/deserialize (in games) 3</h2><div class="ulist"><ul><li><p>Game state</p><div class="ulist"><ul><li><p>player positions (probably in the node hierarchy)</p></li><li><p>Scores</p></li><li><p>Health (possibly in the node hierarchy)</p></li><li><p>&#8230;&#8203;</p></li></ul></div></li></ul></div></section><section id="_common_kinds_of_data_for_serialize_deserialize_in_games_4"><h2>Common kinds of data for serialize/deserialize (in games) 4</h2><div class="ulist"><ul><li><p>Code!!</p><div class="ulist"><ul><li><p>interpretable code</p></li><li><p>Virtual Machine code (<a href="http://fabiensanglard.net/quake3/qvm.php">Quake 3 delegates much of its internal to a custom VM (QVM)</a>)</p></li><li><p>Dynamically linked code</p></li><li><p>Updates?</p></li></ul></div></li></ul></div></section><section id="_common_kinds_of_data_for_serialize_deserialize_in_games_5"><h2>Common kinds of data for serialize/deserialize (in games) 5</h2><div class="ulist"><ul><li><p>We should mostly try to use Standard formats</p></li><li><p>Inevitably there will be cases where we need a custom format</p><div class="ulist"><ul><li><p>usually, we want to use a Standard Generic format for that</p><div class="ulist"><ul><li><p>e.g. JSON, XML, Thrift, Protocol Buffers</p></li></ul></div></li><li><p>occasionally, we may need some custom</p></li></ul></div></li></ul></div></section></section>
<section><section id="_challenges_in_serialization"><h2>Challenges in Serialization</h2><div class="ulist"><ul><li><p>Standardization of formats</p></li><li><p>Text vs. Binary formats</p></li><li><p>Representing the data structures</p><div class="ulist"><ul><li><p>Inheritance hierarchies</p></li><li><p>Pointers/References</p><div class="ulist"><ul><li><p>trees</p></li><li><p>acyclic graphs with joins only at leaves</p></li><li><p>graph (cyclic, arbitrary joins))</p></li></ul></div></li></ul></div></li></ul></div></section><section id="_challenges_in_serialization_2"><h2>Challenges in Serialization 2</h2><div class="ulist"><ul><li><p>Escape sequences</p></li><li><p>Schemas and versions</p></li><li><p>Endianness</p></li><li><p>Compression</p></li></ul></div></section></section>
<section><section id="_standard_formats"><h2>Standard formats</h2><div class="ulist"><ul><li><p>You&#8217;ve no doubt come across many Serialization formats before</p><div class="ulist"><ul><li><p>any format where the data you&#8217;re interested in isn&#8217;t just linear/serial data (and even then)</p></li></ul></div></li><li><p>There are literally thousands of standards</p><div class="ulist"><ul><li><p>in Windows world, every different file ending is (usually) a different file format</p></li></ul></div></li></ul></div></section><section id="_standard_formats_2"><h2>Standard formats 2</h2><div class="ulist"><ul><li><p>Even for common types of data (e.g. images) choosing the format is non-trivial</p></li><li><p>Almost every format has trade offs, e.g.</p><div class="ulist"><ul><li><p><code>jpg</code> can highly compresses the image, creating small files</p><div class="ulist"><ul><li><p>usually smaller than <code>png</code></p></li></ul></div></li><li><p><code>jpg</code> looses information important for some situations (especially fonts)</p></li><li><p><code>jpg</code> has a lot of related patents</p></li><li><p><code>jpg</code> doesn&#8217;t support transparency</p></li><li><p>not all <code>jpg</code> libraries can decode all <code>jpg</code> images</p></li><li><p>production/asset pipeline at Studio XX is using <code>???</code></p></li></ul></div></li></ul></div></section><section id="_standard_formats_3"><h2>Standard formats 3</h2><div class="ulist"><ul><li><p>Not all files in a standard format may be compliant with that standard</p></li><li><p>Some tools may embed extra (perhaps important) data in the standard format</p><div class="ulist"><ul><li><p>your library may not extract that</p></li><li><p>e.g. EXIF data in images</p></li></ul></div></li></ul></div></section><section id="_standard_formats_some_examples"><h2>Standard formats, some examples</h2><div class="ulist"><ul><li><p>You&#8217;ve probably come across some of these before</p><div class="ulist"><ul><li><p>JPEG, PNG, TARGA, TIFF</p></li><li><p>AVI, MPEG, mp3</p></li><li><p>3DS, OBJ, SVG, OBJ</p></li><li><p>DOCX, PPTX, DOC, PPT</p></li><li><p>HTML, CSS, JS</p></li></ul></div></li></ul></div></section></section>
<section id="_standard_generic_formats_some_examples"><h2>Standard Generic formats, some examples</h2><div class="ulist"><ul><li><p>You&#8217;ve probably come across some of these before</p><div class="ulist"><ul><li><p>JSON</p></li><li><p>CSV,</p></li><li><p>XML,</p></li><li><p>Protocol Buffers</p></li><li><p>MsgPack</p></li></ul></div></li></ul></div></section>
<section><section id="_text_vs_binary_formats"><h2>Text vs. binary formats</h2><div class="ulist"><ul><li><p>AKA: Human-readable vs. non-human-readable</p></li></ul></div></section><section id="_text_formats"><h2>Text Formats</h2><div class="ulist"><ul><li><p>Text formats use ASCII, or Unicode to represent data</p><div class="ulist"><ul><li><p>size of the data type and endianness don&#8217;t matter</p></li><li><p>easier for debug/check/read (open in a text editor)</p></li><li><p>tends to be larger</p></li><li><p>can, <strong>sometimes</strong> compress to a similar size</p></li></ul></div></li></ul></div></section><section id="_binary"><h2>Binary</h2><div class="ulist"><ul><li><p>Binary formats represent the data directly as bits/bytes</p><div class="ulist"><ul><li><p>often these bits/bytes may relate closer/exactly to the bits/bytes that will be/were in RAM</p></li><li><p>typically, faster to load (usually, <strong>lots</strong> faster)</p></li><li><p>endianness problems</p></li><li><p>usually smaller files</p></li></ul></div></li></ul></div></section></section>
<section><section id="_file_endings_magic_tags"><h2>File endings, Magic tags, &#8230;&#8203;</h2><div class="ulist"><ul><li><p>Any file is just a stream of bits/bytes and a file name</p></li><li><p>Any message we receive through the network is just a series of bits/bytes</p></li><li><p>How do we know what that data represents?</p><div class="ulist"><ul><li><p>What format it is in?</p></li></ul></div></li><li><p>Perhaps we know from some other context (i.e. we asked for data in some format)</p></li><li><p>Frequently, especially with files, we don&#8217;t know</p></li></ul></div></section><section id="_file_endings_magic_tags_2"><h2>File endings, Magic tags, &#8230;&#8203; 2</h2><div class="ulist"><ul><li><p>The end of a file (after the last <code>.</code>) might help us</p><div class="ulist"><ul><li><p>but is not guaranteed</p></li></ul></div></li><li><p>We may have been told through the protocol (common in Web) (Mime-types)</p><div class="ulist"><ul><li><p>not guaranteed</p></li></ul></div></li><li><p>There may be a magic string (signature) in the byte stream</p><div class="ulist"><ul><li><p><a href="https://en.wikipedia.org/wiki/Portable_Network_Graphics#File_header" class="bare">https://en.wikipedia.org/wiki/Portable_Network_Graphics#File_header</a></p></li><li><p>not guaranteed</p></li></ul></div></li><li><p>We may have to guess, or try to different deserializers till we get something that <code>works</code></p><div class="ulist"><ul><li><p>e.g. try to load what we think is an image with a <code>jpg</code> decoder, perhaps it will work</p></li></ul></div></li></ul></div></section><section id="_file_endings_magic_tags_3"><h2>File endings, Magic tags, &#8230;&#8203; 3</h2><div class="imageblock" style=""><div class="content"><a class="image" href="https://commons.wikimedia.org/wiki/File:PNG-Gradient_hex.png"><img src="./assets/serialization/PNG-Gradient_hex.png" alt="PNG signature" height="600"></a></div></div>
<div class="paragraph"><p><a href="https://en.wikipedia.org/wiki/Portable_Network_Graphics#File_header" class="bare">https://en.wikipedia.org/wiki/Portable_Network_Graphics#File_header</a></p></div></section><section id="_file_endings_magic_tags_4"><h2>File endings, Magic tags, &#8230;&#8203; 4</h2><div class="ulist"><ul><li><p>We can guarantee that deserialisation will always work</p></li><li><p>BUT, we can improve the likelyhood</p><div class="ulist"><ul><li><p>&#8230;&#8203;</p></li></ul></div></li></ul></div></section></section>
<section><section id="_serialization_and_compression"><h2>Serialization and compression</h2><div class="ulist"><ul><li><p>Compression is the process of trying to represent a bit stream in as fewer bits as possible</p><div class="ulist"><ul><li><p>possibly in a <strong>lossy</strong> manner</p></li></ul></div></li><li><p>Serialization and compression tend to be highly interlinked</p></li><li><p>If we know the context of the data (what it is, what we need to use it for) we can usually compress better</p><div class="ulist"><ul><li><p>but this may be overkill - profile before optimization</p></li></ul></div></li><li><p>We can always do generic compression on a bit stream</p><div class="ulist"><ul><li><p>it just may not compress very much</p></li></ul></div></li></ul></div></section><section id="_serialization_and_compression_a_brief_case_study"><h2>Serialization and compression - a brief case-study</h2><div class="ulist"><ul><li><p><code>.docx</code> files are a standard document file format</p></li><li><p>these files are just a special <code>zip</code> file</p><div class="ulist"><ul><li><p>Office Open XML</p></li><li><p>a zip with XML files in it</p></li><li><p>and with some non-XML content (foreign resources)</p><div class="ulist"><ul><li><p>images, video, &#8230;&#8203;</p></li></ul></div></li></ul></div></li></ul></div></section></section>
<section id="_language_support_for_serialization"><h2>Language support for Serialization</h2><div class="ulist"><ul><li><p>C++ doesn&#8217;t have direct support for serialization</p></li><li><p>There are many libraries for standard formats</p></li><li><p>There are many libraries for standard generic formats</p><div class="ulist"><ul><li><p><a href="http://fffaraz.github.io/awesome-cpp/#serialization" class="bare">http://fffaraz.github.io/awesome-cpp/#serialization</a></p></li><li><p><a href="http://fffaraz.github.io/awesome-cpp/#json" class="bare">http://fffaraz.github.io/awesome-cpp/#json</a></p></li><li><p><a href="http://fffaraz.github.io/awesome-cpp/#xml" class="bare">http://fffaraz.github.io/awesome-cpp/#xml</a></p></li></ul></div></li></ul></div></section>
<section id="_serialization_between_languages"><h2>Serialization between languages</h2><div class="ulist"><ul><li><p>Not all languages support the same features and different machines may have different internal representations</p><div class="ulist"><ul><li><p>Javascript has only 64-floating point (no ints, no 32-bit floats)</p></li><li><p><a href="https://en.wikipedia.org/wiki/Endianness">Big-Endian vs. Little-Endian</a></p></li></ul></div></li><li><p>Also:</p><div class="ulist"><ul><li><p>languages come and go</p></li><li><p>languages evolve</p></li></ul></div></li></ul></div></section>
<section><section id="_libraries_vs_custom_serialization_vs"><h2>Libraries vs. Custom Serialization vs. ???</h2><div class="ulist"><ul><li><p>There are many, varied libraries that support/allow Serialization</p></li><li><p>Sometimes writing your own is easier?</p><div class="ulist"><ul><li><p>maybe?</p></li><li><p>especially with Deserializers</p><div class="ulist"><ul><li><p>some part of your production pipeline may have data in some unusually (made up, &#8230;&#8203;) format</p></li><li><p>Twisting a Serialization library to deal with that may be difficult</p></li></ul></div></li></ul></div></li></ul></div></section><section id="_libraries_vs_custom_serialization_vs_2"><h2>Libraries vs. Custom Serialization vs. ???</h2><div class="ulist"><ul><li><p>Most libraries will let you do custom serialization within the library</p></li></ul></div></section></section>
<section><section id="_schema_and_versions"><h2>Schema and Versions</h2><div class="ulist"><ul><li><p>Given we need to (re)construct objects from a bit stream, we need to know the relationship between the bit stream and our objects</p></li><li><p>A schema defines this relationship</p></li><li><p>The schema may be:</p><div class="ulist"><ul><li><p>implicit in our code</p></li><li><p>explicit in some documentation</p></li><li><p>explicit in a machine readable format</p><div class="ulist"><ul><li><p>sent with each file/message</p></li><li><p>or shared separately</p></li></ul></div></li></ul></div></li></ul></div></section><section id="_schema_and_versions_2"><h2>Schema and Versions 2</h2><div class="ulist"><ul><li><p>Schemas (Schemata) change over time</p><div class="ulist"><ul><li><p>your scheme should encode a version (somehow!!!!)</p></li></ul></div></li><li><p>Perhaps you want to put new/different data in your format</p></li><li><p>Perhaps your format is auto-generated from your code, and your objects have changed</p></li><li><p>What about files/message from an older/different schema</p><div class="ulist"><ul><li><p>forwards/backwards compatibility</p></li></ul></div></li></ul></div></section></section>
<section id="_serialization_and_security"><h2>Serialization and security</h2><div class="ulist"><ul><li><p>Data from any outside source shouldn&#8217;t be trusted!</p><div class="ulist"><ul><li><p>network</p></li><li><p>file system</p><div class="ulist"><ul><li><p>perhaps you trust files installed by your programs installer</p></li><li><p>which should be only accessible to your program</p></li><li><p>except for the administrator(s) &#8230;&#8203;</p></li></ul></div></li></ul></div></li><li><p>Outside our scope here</p></li></ul></div></section>
<section id="_serialization_and_computational_cost"><h2>Serialization and Computational cost</h2><div class="ulist"><ul><li><p>Both serialization and deserialization can be computationally expensive</p><div class="ulist"><ul><li><p>as can compression/decompression</p></li></ul></div></li><li><p>Libraries are probably good at this</p></li><li><p>We should profile to see if this is a problem.</p></li><li><p>Where real-time is an issue, we should take that into account</p></li></ul></div></section>
<section><section id="_practical_serialization"><h2>Practical Serialization</h2><div class="olist arabic"><ol class="arabic"><li><p>Delegate to a library</p></li><li><p>Optimize when you have (after profiling)</p></li><li><p>Use Standard formats where possible</p></li><li><p>then use Standard Generic formats where possible</p></li><li><p>Serializing just <strong>changes</strong>??</p></li></ol></div></section><section id="_practical_serialization_2"><h2>Practical Serialization</h2><div class="ulist"><ul><li><p>As our games become more generic, more game-engine like, we would like to serialize in more Standard formats</p></li><li><p>There is a trade-of between Standard formats and Standard Generic formats</p><div class="ulist"><ul><li><p>the former may be needlessly complex for our needs</p></li><li><p>for our learning, and practically for this module, we&#8217;ll look at using Standard Generic formats</p></li></ul></div></li></ul></div></section></section>
<section><section id="_cereal"><h2>Cereal</h2><div class="ulist"><ul><li><p><a href="http://uscilab.github.io/cereal/" class="bare">http://uscilab.github.io/cereal/</a></p></li></ul></div><div class="listingblock"><div class="content"><pre>cereal is a header-only C++11 serialization library. cereal takes arbitrary data types and reversibly turns them into different representations, such as compact binary encodings, XML, or JSON. cereal was designed to be fast, light-weight, and easy to extend - it has no external dependencies and can be easily bundled with other code or used standalone.</pre></div></div></section><section id="_cereal_2"><h2>Cereal</h2><div class="ulist"><ul><li><p>Cereal can use XML, JSON, or its own binary format</p></li><li><p>Cereal can serialize C++ base types automatically</p></li><li><p>Cereal can serialize C++ standard library class automatically (std::vector)</p></li><li><p>Cereal can serialize smart pointers</p></li><li><p>It&#8217;s easy to make Cereal serialize your own classes</p></li></ul></div></section></section>
<section id="_other_reading"><h2>Other Reading</h2><div class="ulist"><ul><li><p><a href="https://isocpp.org/wiki/faq/serialization" class="bare">https://isocpp.org/wiki/faq/serialization</a></p></li><li><p><a href="http://gafferongames.com/building-a-game-network-protocol/" class="bare">http://gafferongames.com/building-a-game-network-protocol/</a></p></li></ul></div></section>
<section><section id="_workshop_activities_1"><h2>Workshop activities 1</h2><div class="ulist"><ul><li><p>Download the Cereal library, or select another</p><div class="ulist"><ul><li><p><a href="http://fffaraz.github.io/awesome-cpp/#serialization" class="bare">http://fffaraz.github.io/awesome-cpp/#serialization</a></p></li><li><p><a href="http://fffaraz.github.io/awesome-cpp/#json" class="bare">http://fffaraz.github.io/awesome-cpp/#json</a></p></li><li><p><a href="http://fffaraz.github.io/awesome-cpp/#xml" class="bare">http://fffaraz.github.io/awesome-cpp/#xml</a></p></li></ul></div></li></ul></div></section><section id="_workshop_activities_2"><h2>Workshop activities 2</h2><div class="ulist"><ul><li><p><code>#include</code> the library</p><div class="ulist"><ul><li><p>for other libraries you may also need to modify premake for libraries, and dlls</p></li></ul></div></li></ul></div></section><section id="_workshop_activities_3"><h2>Workshop activities 3</h2><div class="ulist"><ul><li><p>serialize the following to some file, then deserialize each (use XML or JSON). Look at the generated files</p><div class="ulist"><ul><li><p>an int</p></li><li><p>a float</p></li><li><p>a list of float</p></li><li><p>your own class</p></li><li><p>a list of your own classes</p></li></ul></div></li></ul></div></section><section id="_workshop_activities_4"><h2>Workshop activities 4</h2><div class="ulist"><ul><li><p>repeat for each, in a binary format. Compare the file sizes</p></li></ul></div></section></section></div></div><script src="reveal.js/lib/js/head.min.js"></script><script src="reveal.js/js/reveal.js"></script><script>// See https://github.com/hakimel/reveal.js#configuration for a full list of configuration options
Reveal.initialize({
  // Display controls in the bottom right corner
  controls: true,
  // Display a presentation progress bar
  progress: true,
  // Display the page number of the current slide
  slideNumber: false,
  // Push each slide change to the browser history
  history: true,
  // Enable keyboard shortcuts for navigation
  keyboard: true,
  // Enable the slide overview mode
  overview: true,
  // Vertical centering of slides
  center: true,
  // Enables touch navigation on devices with touch input
  touch: true,
  // Loop the presentation
  loop: false,
  // Change the presentation direction to be RTL
  rtl: false,
  // Turns fragments on and off globally
  fragments: true,
  // Flags if the presentation is running in an embedded mode,
  // i.e. contained within a limited portion of the screen
  embedded: false,
  // Number of milliseconds between automatically proceeding to the
  // next slide, disabled when set to 0, this value can be overwritten
  // by using a data-autoslide attribute on your slides
  autoSlide: 0,
  // Stop auto-sliding after user input
  autoSlideStoppable: true,
  // Enable slide navigation via mouse wheel
  mouseWheel: false,
  // Hides the address bar on mobile devices
  hideAddressBar: true,
  // Opens links in an iframe preview overlay
  previewLinks: false,
  // Theme (e.g., beige, black, league, night, serif, simple, sky, solarized, white)
  // NOTE setting the theme in the config no longer works in reveal.js 3.x
  //theme: Reveal.getQueryHash().theme || 'black',
  // Transition style (e.g., none, fade, slide, convex, concave, zoom)
  transition: Reveal.getQueryHash().transition || 'slide',
  // Transition speed (e.g., default, fast, slow)
  transitionSpeed: 'default',
  // Transition style for full page slide backgrounds (e.g., none, fade, slide, convex, concave, zoom)
  backgroundTransition: 'fade',
  // Number of slides away from the current that are visible
  viewDistance: 3,
  // Parallax background image (e.g., "'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg'")
  parallaxBackgroundImage: '',
  // Parallax background size in CSS syntax (e.g., "2100px 900px")
  parallaxBackgroundSize: '',

  // The "normal" size of the presentation, aspect ratio will be preserved
  // when the presentation is scaled to fit different resolutions. Can be
  // specified using percentage units.
  width: 960,
  height: 700,

  // Factor of the display size that should remain empty around the content
  margin: 0.1,

  // Bounds for smallest/largest possible scale to apply to content
  minScale: 0.2,
  maxScale: 1.5,

  // Optional libraries used to extend on reveal.js
  dependencies: [
      { src: 'reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
      { src: 'reveal.js/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
      { src: 'reveal.js/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
      { src: 'reveal.js/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
      { src: 'reveal.js/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
      { src: 'reveal.js/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
  ]
});</script></body></html>