<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <title></title>
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <link rel="stylesheet" href="reveal.js/css/reveal.min.css"/>
    <style type="text/css">code{white-space: pre;}</style>
    <link rel="stylesheet" href="reveal.js/css/theme/simple.css" id="theme">
    <!-- If the query includes 'print-pdf', include the PDF print sheet -->
    <script>
      if( window.location.search.match( /print-pdf/gi ) ) {
        var link = document.createElement( 'link' );
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = 'reveal.js/css/print/pdf.css';
        document.getElementsByTagName( 'head' )[0].appendChild( link );
      }
    </script>
    <!--[if lt IE 9]>
    <script src="reveal.js/lib/js/html5shiv.js"></script>
    <![endif]-->
</head>
<body>
  <div class="reveal">
    <div class="slides">


<section><section id="games-programming---lecture-06" class="titleslide slide level1"><h1>Games Programming - Lecture 06</h1></section><section id="overview-of-today" class="level3">
<h3>Overview of Today</h3>
<ul>
<li>Scene Graphs</li>
</ul>
</section></section>
<section><section id="scene-graphs" class="titleslide slide level1"><h1>Scene Graphs</h1></section><section id="concept-of-a-scene-graph" class="level3">
<h3>Concept of a Scene Graph</h3>
<ul>
<li>Objects placed relative to one another</li>
<li>Objects made of similar components</li>
<li>Directed acyclic graph (used as a data structure)</li>
</ul>
<p><img src="assets/sceneGraph001.png" alt="sceneGraph001" height=300></p>
</section><section id="use-for-animationmodelling" class="level3">
<h3>Use for Animation/Modelling</h3>
<p><img src="assets/sceneGraph002.png" alt="sceneGraph002" height=300></p>
</section><section id="how-it-works" class="level3">
<h3>How it works</h3>
<ul>
<li>Each object has a local transformation relative to its parent
<ul>
<li>shoulder is translation (0 1 0) from base</li>
<li>upper arm is translation (0 3 0) from shoulder</li>
<li>elbow is translation (0 3 0) from upper arm</li>
<li>forearm is rotation Z by -90 then translation (0 2 0)</li>
</ul></li>
</ul>
</section><section id="how-it-works---diagram" class="level3">
<h3>How it works - diagram</h3>
<p><img src="assets/sceneGraph003.png" alt="sceneGraph003" height=300></p>
</section><section id="how-it-works---rendering-traverse" class="level3">
<h3>How it works - Rendering Traverse</h3>
<ul>
<li>For each object to render correctly, it needs its modelMatrix to be known in WorldCoordinates</li>
<li>For baseObject, this is straightforwards - its own matrix is already in WC</li>
<li>For all children objects, their own matrix is relative to its parent
<ul>
<li>so we must multiply its relative matrix by its parent's WC matrix</li>
<li>and continue down the graph</li>
<li>i.e. we &quot;inherit&quot; matrices down the stack (graph)</li>
</ul></li>
</ul>
</section><section id="how-it-works---diagram-1" class="level3">
<h3>How it works - diagram</h3>
<p><img src="assets/sceneGraph003.png" alt="sceneGraph003" height=300></p>
</section><section id="scene-graph-efficiency" class="level3">
<h3>Scene Graph Efficiency</h3>
<ul>
<li>calcualting all the inherited values is relatively expensive</li>
<li>we should try to minimise how much we have to recompute these values
<ul>
<li>Discuss ...</li>
</ul></li>
</ul>
</section><section id="another-example" class="level3">
<h3>Another example</h3>
<p><img src="assets/sceneGraph004.png" alt="sceneGraph004" height=500></p>
</section><section id="another-example-generic" class="level3">
<h3>Another example (generic)</h3>
<p><img src="assets/sceneGraph005.png" alt="sceneGraph005" height=500></p>
</section></section>
<section><section id="instancing" class="titleslide slide level1"><h1>Instancing</h1></section><section id="instancing-1" class="level3">
<h3>Instancing</h3>
<ul>
<li>saving memory (CPU and GPU)</li>
<li>increasing cache coherence</li>
<li>https://www.panda3d.org/manual/index.php/Instancing</li>
</ul>
<p><img src="assets/sceneGraph006.jpg" alt="sceneGraph006" height=300></p>
</section><section id="instancing-caveat" class="level3">
<h3>Instancing: Caveat</h3>
<ul>
<li>Instancing saves CPU time and GPU space</li>
<li>But the renderer still needs to render the model multiple times</li>
<li>If we have a 1000 polygon model, and 150 instances, we still have 150,000 polygons</li>
</ul>
</section><section id="instancing-in-practice" class="level3">
<h3>Instancing in practice</h3>
<ul>
<li>Most modern hardward supports hardware instancing</li>
<li>Unfortunately, as of early 2015, Monogame does not yet support hardware instancing
<ul>
<li>http://community.monogame.net/t/hardware-instancing-not-supported/356</li>
</ul></li>
</ul>
</section><section id="instancing-in-opengl" class="level3">
<h3>Instancing in OpenGL</h3>
<ul>
<li>hardware instancing supported since OpenGL 3.1</li>
<li>online guides:
<ul>
<li>https://www.opengl.org/wiki/Vertex_Rendering#Instancing</li>
<li>http://www.gamedev.net/page/resources/_/technical/opengl/opengl-instancing-demystified-r3226</li>
<li>http://ogldev.atspace.co.uk/www/tutorial33/tutorial33.html</li>
<li>http://sol.gfxile.net/instancing.html</li>
</ul></li>
</ul>
</section><section id="impact-of-instancing" class="level3">
<h3>Impact of instancing</h3>
<ul>
<li>from http://sol.gfxile.net/instancing.html</li>
<li>tested on two computers. Both Core i7, 8 GB of RAM and win7 64bit</li>
<li>Nvidia gtx260</li>
<li>ATI hd5700 (we're going to ignore this for now)</li>
<li>Screen refresh sync was turned off for all tests</li>
<li>64000 instances</li>
<li>geometry includes:
<ul>
<li>cubes in vertex arrays (VA)</li>
<li>cubes in vertex buffer objects (VBO)</li>
<li>low (~80 tris) poly count toruses (VBO)</li>
<li>high (~230 tris) poly count toruses (VBO)</li>
</ul></li>
</ul>
</section><section id="impact-of-instancing-2" class="level3">
<h3>Impact of instancing 2</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Situation</th>
<th style="text-align: left;">Nvidia</th>
<th style="text-align: left;"></th>
<th style="text-align: left;"></th>
<th style="text-align: left;"></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;">Cubes(VA)</td>
<td style="text-align: left;">Cubes(VBO)</td>
<td style="text-align: left;">Torus(lo)</td>
<td style="text-align: left;">Torus(hi)</td>
</tr>
<tr class="even">
<td style="text-align: left;">No shaders</td>
<td style="text-align: left;">59.3ms</td>
<td style="text-align: left;">41.1ms</td>
<td style="text-align: left;">41.1ms</td>
<td style="text-align: left;">55.3ms</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Plain shaders</td>
<td style="text-align: left;">86.7ms</td>
<td style="text-align: left;">80.5ms</td>
<td style="text-align: left;">81.0ms</td>
<td style="text-align: left;">80.4ms</td>
</tr>
<tr class="even">
<td style="text-align: left;">Pseudoinstancing</td>
<td style="text-align: left;">70.1ms</td>
<td style="text-align: left;">30.0ms</td>
<td style="text-align: left;">30.4ms</td>
<td style="text-align: left;">51.9ms</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Matrices in texture</td>
<td style="text-align: left;">41.0ms</td>
<td style="text-align: left;">10.4ms</td>
<td style="text-align: left;">22.8ms</td>
<td style="text-align: left;">50.7ms</td>
</tr>
<tr class="even">
<td style="text-align: left;">Matrices in uniforms</td>
<td style="text-align: left;">45.5ms</td>
<td style="text-align: left;">18.7ms</td>
<td style="text-align: left;">23.1ms</td>
<td style="text-align: left;">50.5ms</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>Instanced arrays</strong></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"><strong>11.3ms</strong></td>
<td style="text-align: left;"><strong>22.8ms</strong></td>
<td style="text-align: left;"><strong>53.2ms</strong></td>
</tr>
</tbody>
</table>
</section></section>
<section><section id="cameras-and" class="titleslide slide level1"><h1>Cameras and ++</h1></section><section id="groups-and-leaves" class="level3">
<h3>Groups and Leaves</h3>
<ul>
<li>A Directed Acyclic Graph consists of a set of nodes connected with Directed relationships, containing no Cycles</li>
<li>Our DAG consists of two types of node</li>
</ul>
</section><section id="group-nodes" class="level3">
<h3>Group nodes</h3>
<ul>
<li>any number of child nodes attached to it
<ul>
<li>include transformations and switch nodes</li>
</ul></li>
</ul>
</section><section id="leaf-nodes" class="level3">
<h3>Leaf nodes</h3>
<ul>
<li>nodes that are actually rendered or show the effect of an operation</li>
<li>for us so far, this is meshes (objects)</li>
<li>can also include:
<ul>
<li>sprites</li>
<li>cameras</li>
<li>lights</li>
<li>sounds</li>
<li>and anything that could be considered 'rendered' in some abstract sense</li>
</ul></li>
</ul>
</section><section id="cameras" class="level3">
<h3>Cameras</h3>
<ul>
<li>the World Coordinate transformation applied to our camera will be the camera's relative transformation combined with the inherited transformations</li>
<li>thus we can have:
<ul>
<li>a camera we can control in World Coordinates
<ul>
<li>connected to the root of the scene graph</li>
</ul></li>
<li>a camera that moves with an object
<ul>
<li>connected to the transform node of an object, with an identity matrix for the camera</li>
</ul></li>
<li>a camera that moves with an object, but with relative change
<ul>
<li>connected to the transform node of an object, with a non-identity matrix for the camera</li>
</ul></li>
</ul></li>
</ul>
</section><section id="lights" class="level3">
<h3>Lights</h3>
<ul>
<li>the World Coordinate transformation applied to each light will be the light's relative transformation combined with the inherited transformations</li>
<li>thus we can have:
<ul>
<li>a light we can control in World Coordinates
<ul>
<li>connected to the root of the scene graph</li>
</ul></li>
<li>a light that moves with an object
<ul>
<li>connected to the transform node of an object, with an identity matrix for the camera</li>
</ul></li>
<li>a light that moves with an object, but with relative change
<ul>
<li>connected to the transform node of an object, with a non-identity matrix for the camera</li>
</ul></li>
</ul></li>
</ul>
</section></section>
    </div>
  </div>


  <script src="reveal.js/lib/js/head.min.js"></script>
  <script src="reveal.js/js/reveal.min.js"></script>

  <script>

      // Full list of configuration options available here:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        controls: true,
        progress: true,
        history: true,
        center: true,
        theme: 'sky', // available themes are in /css/theme
        transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none

        // Optional libraries used to extend on reveal.js
        dependencies: [
          { src: 'reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: 'reveal.js/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
          { src: 'reveal.js/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } },
//          { src: 'reveal.js/plugin/search/search.js', async: true, condition: function() { return !!document.body.classList; }, }
//          { src: 'reveal.js/plugin/remotes/remotes.js', async: true, condition: function() { return !!document.body.classList; } }
]});
    </script>
    </body>
</html>
